// Package magic provides pre-computed Magic Bitboard lookup tables for
// sliding piece move generation (Rook, Bishop, Queen).
//
// Magic Bitboards allow O(1) move generation for sliding pieces by using
// a perfect hash function to map blocker configurations to attack bitboards.
//
// Usage:
//
//	magic.Prepare() // call once at startup
//	blockers := allPieces & magic.RookMagics[square].Mask
//	index := (uint64(blockers) * magic.RookMagics[square].Number) >> magic.RookMagics[square].Shift
//	attacks := magic.RookMoves[square][index]
package magic

import (
	"bytes"
	_ "embed"
	"encoding/gob"
	"fmt"
)

// Bitboard is a local type alias to avoid import cycle with board package.
// Both board.Bitboard and magic.Bitboard are uint64, so they're compatible.
type Bitboard = uint64

// magicData contains pre-computed magic numbers and lookup tables.
// Generated by: go run generate.go (in magic/ directory)
//
//go:embed magicData
var magicData []byte

// Magic holds the magic number and parameters for a single square.
type Magic struct {
	Number uint64   // Magic multiplier for perfect hashing
	Mask   Bitboard // Blocker mask (relevant squares that can block)
	Shift  uint8    // Right shift amount: 64 - number_of_blocker_bits
}

// Pre-computed data for all 64 squares.
// RookMoves uses 4096 entries (max 12 bits for rook blockers).
// BishopMoves uses 512 entries (max 9 bits for bishop blockers).
var RookMagics [64]Magic
var BishopMagics [64]Magic
var RookMoves [64][4096]Bitboard
var BishopMoves [64][512]Bitboard

// Prepare loads the magic bitboard data from embedded binary.
// Must be called once before using RookMoves/BishopMoves.
func Prepare() error {
	dec := gob.NewDecoder(bytes.NewReader(magicData))

	err := dec.Decode(&RookMagics)
	if err != nil {
		return fmt.Errorf("decode error RookMagics: %w", err)
	}
	err = dec.Decode(&RookMoves)
	if err != nil {
		return fmt.Errorf("decode error RookMoves: %w", err)
	}
	err = dec.Decode(&BishopMagics)
	if err != nil {
		return fmt.Errorf("decode error BishopMagics: %w", err)
	}
	err = dec.Decode(&BishopMoves)
	if err != nil {
		return fmt.Errorf("decode error BishopMoves: %w", err)
	}
	return nil
}
